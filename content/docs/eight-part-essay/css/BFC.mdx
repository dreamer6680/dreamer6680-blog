---
 title: Css上下文
---

### BFC

BFC（ `Block Formatting Context`， 名为 "块级格式化上下文"）个人理解指的是一个独立的渲染区域，
BFC 内部的元素布局与外部互不影响。

触发 BFC 的方式常见的有：

+   float设置为 left、right
+   overflow 设置为非 visible（默认是visible），还有`hidden,scroll,auto,clip`
+   positon 设置为 absolute、fixed
+   display: inline-block
+   display: table-cell
+   display: flex
+   display: table-caption
+   **优先使用 `display: flow-root`** CSS3 专为 BFC 设计的属性，无副作用

常见的 BFC 应用有：

+   解决浮动元素令父元素高度坍塌的问题（计算 BFC 的高度时，浮动子元素也参与计算）
+   解决非浮动元素被浮动元素覆盖问题
+   解决同一个 BFC 外边距垂直方向重合的问题
+   阻止外边距合并（Margin Collapse）
+   包含内部浮动元素（清除浮动）
+   隔离外部浮动影响

解决margin塌陷问题

为了解决此问题可以使用`BFC`规则（为元素包裹一个盒子形成一个完全独立的空间，做到里面元素不受外面布局影响 （可以给其中一个盒子套一个p标签、套一个displayflex、一个overflowhidden）

### IFC

内联格式化上下文（IFC） **定义** ：内联元素（如文本、`span`）的排列环境，元素水平排列，直到占满一行后换行。  
**触发条件** ：元素为 `display: inline/inline-block` 或默认内联元素。

style="vertical-align: middle;"

**特性** ：

+   元素水平排列，基线（baseline）对齐
+   行框（Line Box）高度由行内最高元素决定

### FFC

弹性格式化上下文（FFC） **定义** ：弹性容器（Flex Container）通过弹性布局控制子元素排列。  
**触发条件** ：`display: flex/inline-flex`

**特性** ：

+   子元素按主轴（main axis）排列，可伸缩尺寸
+   支持 `flex-grow`、`flex-shrink`、`flex-basis` 控制空间分配

### GFC

网格格式化上下文（GFC）

**定义** ：网格容器（Grid Container）实现二维布局。  
**触发条件** ：`display: grid/inline-grid`

**特性** ：

+   通过行和列定义布局结构
+   支持 `grid-template-rows/columns` 定义网格轨道

### TFC

表格格式化上下文（TFC

**定义** ：表格及其单元格的布局规则。  
**触发条件** ：`display: table/table-cell`

**特性** ：

+   模拟传统表格布局
+   支持 `border-collapse` 控制边框合并

## BFC

### 块元素场景

#### 1.水平方向上,撑满整个包含块宽度,垂直方向上,依次摆放

#### 2.垂直方向上相邻的元素,margin会合并(可以解决，让中间的元素设置上下)

```
        .box {
            overflow: hidden; /* 每个 box 都是独立 BFC */
            margin: 20px;
        }
    /* 两个 .box 之间的 margin 会保持 20px，而非合并为 20px */
```

#### 3.父子关系的情况下,可能会产生margin塌陷

不设置会发现第一个盒子的上部和最后一个盒子的下部的margin被父元素吞了

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .outer {
            width: 300px;
            background-color: pink;
            /*float: left */
        }
        .inner {
            width: 100px;
            height: 100px;
            margin: 20px;
        }
        .box1 {
            background-color: rgb(148, 127, 255);
        }
        .box2 {
            background-color: rgb(255, 148, 127);
        }
        .box3 {
            background-color: rgb(127, 255, 148);
        }

    </style>
</head>
<body>
 <div class="outer">
    <div class="inner box1"></div>
    <div class="inner box2"></div>
    <div class="inner box3"></div>
 </div>

    
</body>
</html>
```

#### 4.父子关系的情况下,父元素无视浮动元素会产生高度坍塌

子元素浮动脱离文档流，但是父元素没有脱离文档流，导致父元素没有高度而不可见

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .outer {
            width: 300px;
            background-color: pink;
        }
        .inner {
            width: 100px;
            height: 100px;
            float: left 
        }
        .box1 {
            background-color: rgb(148, 127, 255);
        }
        .box2 {
            background-color: rgb(255, 148, 127);
        }
        .box3 {
            background-color: rgb(127, 255, 148);
        }

    </style>
</head>
<body>
 <div class="outer">
    <div class="inner box1"></div>
    <div class="inner box2"></div>
    <div class="inner box3"></div>
 </div>

    
</body>
</html>
```

#### 5.兄弟关系的情况下,正常元素可能会被浮动元素覆盖

第一个元素开启float后脱离文档流，导致后面的元素钻进去了

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .one{
            width: 100px;
            height: 100px;
            background-color: pink;
            float: left;
        }
        .two{
            width: 100px;
            height: 100px;
            background-color: rgb(127, 255, 148);
        }

    </style>
</head>
<body>
    <div class="one"></div>
    <div class="two"></div>

    
</body>
</html>
```

### BFC的实现

BFC 容器（bfc）：计算高度时会扫描到浮动子元素的底部位置（距离顶部 100px），因此容器高度被修正为 100px，边框完整包裹浮动元素。

#### 为什么 overflow: hidden 能触发这种行为？

overflow: hidden 是最常用的触发 BFC 的方式，它能让容器包裹浮动元素的原因是：当元素设置 overflow: hidden 时，浏览器需要确保容器内的所有内容（包括浮动元素）都不会超出容器边界（否则会被裁剪）。为了实现这个效果，浏览器必须主动计算所有浮动元素的位置和高度，并据此调整容器自身的高度 —— 这正是 BFC 对浮动元素的 “强制捕获” 逻辑。
其他触发 BFC 的方式（如 display: flex、position: absolute 等）虽然触发条件不同，但最终都会激活浏览器的 “BFC 布局模式”，从而执行相同的浮动捕获和高度修正逻辑。