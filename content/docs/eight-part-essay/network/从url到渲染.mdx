---
 title: 从url到渲染页面的过程
---

## 输入URL之后发生了什么

![](http://gaga0714.site/assets/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88-20240704195729729.r6SvyUvD.jpg)

+   用户输入 url 并回车
    
+   浏览器进程检查url，组装协议，构成完整的 url
    
+   浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
    
+   网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
    
+   **如果没有，网络进程向web服务器发起http请求（网络请求）：**
    
    +   进行DNS解析（浏览器缓存->系统缓存 host->本地服务器->远程服务器），获取服务器ip地址
    +   利用 ip 地址和服务器建立 tcp 连接(三z次握手) 打开端口
    +   构建请求头信息
    +   发送请求头信息
    +   服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
        +   初始请求的响应包含所接收数据的第一个字节。[首字节时间（TTFB）](https://developer.mozilla.org/zh-CN/docs/Glossary/Time_to_first_byte)是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 14KB 的数据。
+   **网络进程解析响应流程**；
    
    +   检查状态码，如果是 3开头，则需要重定向，从Location自动中读取地址，重新进行第4步 （301永久通常变为GET（会读本地缓存 ）302临时通常变为GET（不会）/307 临时不能更改方法 308永久不能更改方法），如果是200，则继续处理请求。
    +   200响应处理：检查响应类型 Content-Type ，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 `html`则通知浏览器进程准备渲染进程准备进行渲染。
+   **准备渲染进程**
    
    +   浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
+   **传输数据、更新状态**
    
    +   渲染进程准备好后，浏览器通过 IPC 向渲染进程发送文档的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    +   渲染进程接收完数据后，向浏览器发送“确认提交”
    +   浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面
    +   渲染进程开始渲染
+   **页面渲染**
    
    +   通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值
    +   通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算"Frame 树"中每个节点的首选(preferred)宽度
    +   通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度
    +   通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)
    +   使用上面的计算结果构建每个节点的坐标
    +   创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层
    +   每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制
    +   上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量
    +   计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。

1.  浏览器输入的 url 经过 DNS 解析获得对应的 IP 地址
2.  向服务器发起 TCP 的 3 次握手
3.  建立链接后，浏览器向该IP地址发送 http 请求
4.  服务器接收到请求，HMTL 格式的字符串代码
5.  浏览器获得 html 代码，解析成 DOM 树，同时 js 阻塞解析
6.  获取 CSS 并构建 CSSOM
7.  将 DOM 与 CSSOM 结合，创建渲染树
8.  找到所有内容都处于网页的哪个位置，布局渲染树
9.  最终绘制出页面

## 页面渲染

一、页面渲染核心流程拆解（附技术细节）
浏览器渲染是 **“从代码到像素” 的线性流程，但部分步骤会因优化产生依赖或复用 **，具体可分为 8 个关键阶段，每个阶段的输入、输出和核心逻辑如下：
阶段	核心任务	关键细节	输入 / 输出
1. 构建渲染树（Render Tree）	将 DOM 树与 CSSOM 树结合，生成 “可见节点 + 样式” 的树结构	- 过滤不可见节点：如display: none的元素、`<head>`内标签、被遮挡节点（如z-index下层完全覆盖的元素）
- 关联样式：给每个 DOM 节点匹配最终 CSS 样式（需处理样式优先级：!important > 内联 > ID > 类 / 伪类 > 元素选择器）	输入：DOM 树、CSSOM 树
输出：渲染树（每个节点含 “样式属性 + 可见状态”）
2. 计算首选宽度（Preferred Width）	自底向上（从叶子节点到根节点）计算每个节点的 “理想宽度”	- 宽度计算规则：
① 叶子节点（如文本、图片）：文本默认按内容宽度（无换行时），图片按src原始尺寸或width属性
② 父节点：累加所有子节点的首选宽度 + 自身padding（内边距）+ border（边框）+ margin（外边距）
- 特殊情况：若节点设置width: auto，首选宽度即 “子节点总宽 + 自身盒模型”；若设固定width，则首选宽度直接取固定值	输入：渲染树、CSS 盒模型属性
输出：每个节点的 “首选宽度”（理想状态下的宽度）
3. 分配实际宽度（Actual Width）	自顶向下（从根节点到叶子节点）调整节点宽度，适配父容器限制	- 核心逻辑：父节点先确定自身 “可用宽度”（如根节点`<html>`的宽度 = 浏览器视口宽度 - 滚动条宽度），再给子节点分配宽度：
① 若子节点有固定宽度（如width: 200px），直接使用固定值
② 若子节点为width: 100%，则继承父节点可用宽度（需减去子节点自身margin/padding/border）
③ 若子节点为width: auto，则用 “父节点可用宽度 - 其他子节点总宽” 反向计算	输入：首选宽度、父节点可用宽度、CSS 宽度属性
输出：每个节点的 “实际宽度”（最终渲染宽度）
4. 计算节点高度与文字折行	确定每个节点的实际高度，处理文本换行和内容溢出	- 文字折行：根据节点实际宽度，计算文本需拆分的行数（需考虑字体大小font-size、行高line-height、单词长度等，如英文按空格折行，中文按字符折行）
- 高度计算：
① 文本节点：行数 × 行高（若有line-height）
② 父节点：累加所有子节点的实际高度 + 自身padding + border + margin（注意：margin垂直方向会折叠，如父子节点margin-top重叠时取较大值）
- 特殊情况：若节点设height: auto，高度由内容决定；若设固定height，内容溢出时按overflow属性处理（显示滚动条 / 隐藏 / 溢出）	输入：实际宽度、CSS 高度 / 行高 / 溢出属性、文本内容
输出：每个节点的 “实际高度”“文本换行位置”
5. 计算节点坐标（Layout/Reflow）	确定每个节点在屏幕上的绝对位置（x,y 坐标）	- 坐标基准：根节点`<html>`的左上角为原点 (0,0)
- 计算逻辑：
① 块级元素（如`<div>`）：默认垂直排列，y 坐标 = 上一个兄弟节点的 y 坐标 + 上一个节点高度
② 行内元素（如`<span>`）：水平排列，x 坐标 = 上一个兄弟节点的 x 坐标 + 上一个节点宽度，超出父节点宽度时自动换行
③ 定位元素（position: absolute/fixed）：脱离文档流，坐标基于最近的定位祖先节点（absolute）或视口（fixed）	输入：实际宽度 / 高度、CSS 定位属性（position/float）
输出：每个节点的 “屏幕坐标（x,y）”
6. 分层（Layer Compositing）	将渲染树拆分为多个 “层（Layer）”，减少重绘范围	- 分层依据（浏览器自动判断）：
① 有 3D 变换（transform: translate3d）或will-change属性的元素
② 视频、Canvas、WebGL 元素
③ 滚动容器（如带overflow: auto的节点）
④ 被其他层覆盖的节点（需单独分层避免重绘）
- 分层优势：后续绘制时，仅重绘变化的层（如滚动时只更新滚动层，不重绘整个页面），且层可通过 GPU 并行处理	输入：渲染树、节点属性（变换 / 滚动 / 媒体类型）
输出：分层结构（每个层包含一组渲染树节点）
7. 绘制层内容（Paint）	遍历每层的节点，生成 “绘图命令”（如画矩形、文本、图片）	- 绘制逻辑：按节点层级（从后到前，避免遮挡）执行命令：
① 基础图形：如background-color（画矩形）、border（画边框线条）
② 文本：调用字体渲染引擎（如 FreeType）绘制字符
③ 图片：解码图片（如 PNG/JPG）后绘制到指定坐标
- 绘制执行：
- 简单绘制（如纯色背景）：CPU 生成绘图命令后，直接传给 GPU
- 复杂绘制（如模糊效果、渐变）：CPU 先做栅格化（将矢量命令转化为像素），再送 GPU；或通过 SkiaGL/D2D（浏览器绘图引擎）直接在 GPU 上绘制	输入：分层结构、节点样式 / 坐标 / 内容
输出：每层的 “绘图命令”“像素数据（部分）”
8. 合成与显示（Composite）	将所有层的像素合成到屏幕，完成渲染	- 核心步骤：
① 计算层位置：确定每个层在最终屏幕上的叠加顺序（按z-index和分层顺序）
② GPU 命令生成：浏览器通过 Direct3D（Windows）/OpenGL（Linux）/Metal（macOS）向 GPU 发送 “合成命令”
③ 异步渲染：GPU 清空命令缓冲区，执行合成操作（并行处理多层像素）
④ 显示输出：合成后的帧（Frame）发送到 Window Server（系统窗口服务），最终显示在屏幕上	输入：分层像素数据、层位置
输出：屏幕可见的最终帧